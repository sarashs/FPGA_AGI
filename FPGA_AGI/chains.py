#from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field
from langchain import OpenAI, LLMChain, PromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.llms import BaseLLM
import os
import warnings

def strip_json(input_string: str):
        # Search for the start and end of the json content
        start = input_string.find("```json")
        end = input_string.find("```", start + 1)
        # Extract and return the content if both markers are found, else raise an error
        if start != -1 and end != -1:
            return input_string[start + len("```json"):end].strip()
        else:
            warnings.warn("No JSON content found")
            return input_string

class ModuleListCreationChain(LLMChain):
    """Chain to generates detailed level module names, dependencies, inputs and descriptions."""

    examples: dict = Field(default_factory=dict)
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain: # take a step by step approach and explain your thoughts on how you are going to perform the high level design.
        """Get the response parser."""
        task_creation_template = """Objective: Design a comprehensive list of essential modules for a hardware project based on the provided specifications:
Specifications: 
{objective}
Design Constraint: The design should be flat, with no submodules under another module.

1. Understanding the Project Objective:
   - Analyze the given specifications.
   - Identify key functions, goals, and requirements of the hardware project.
   - Clarify any ambiguities or gaps in the provided information.

2. Module Identification:
   - Reflect on the project's objectives to identify all necessary modules.
   - Ensure each module is a standalone component or function.
   - Avoid overlapping functionalities for clarity and efficiency.

3. Adherence to Flat Design Principle:
   - Ensure the design remains flat with no submodules.
   - Focus on how each module independently contributes to the overall project.

4. Functional Clarity:
   - Define the function of each module clearly.
   - Describe its contribution to the project's objectives and interactions with other modules.

5. Coherence and Integration:
   - Ensure all modules form a coherent and integrated system.
   - Align module inputs and outputs for seamless integration.
   - Focus on overall design functionality and efficiency.

6. Complete JSON Format Design Return:
   - Return the design in JSON format with all modules listed.
   - Ensure every necessary module for the project is included, not just a subset.
   - Ensure that the output is in a single JSON.

Output Format:
```json
{{
  "Module_Name": {{
    "ports": ["specific inputs and outputs, including bit width"],
    "description": "detailed description of the module function",
    "connections": ["specific other modules it must connect to"],
  }},
  "Another_Module_Name": {{
    "ports": ["specific inputs and outputs, including bit width"],
    "description": "detailed description of the module function",
    "connections": ["specific other modules it must connect to"],
  }},
  // Include each additional module required for the project
}}
```
"""
        prompt = PromptTemplate(
            template=task_creation_template,
            input_variables=["objective"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)

class ModuleListEvaluationChain(LLMChain):
    """Chain to generates module names. dependencies and plans."""

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain: # take a step by step approach and explain your thoughts on how you are going to perform the high level design.
        """Get the response parser."""
        task_evaluation_template = """
Task Overview: Evaluate and refine a hardware project design generated by an LLM, provided in JSON format:
{design}
based on the following specifications:
{objective}
Your goal is to methodically analyze and adjust the design, focusing on Initial Assessment, Module Relevance Check, Module Completeness Check, Compatibility Analysis, and Coherence Evaluation.
Initial Assessment:
Start by thoroughly reviewing the JSON design.
Identify the purpose and functionality of each module.
Note any immediate observations or concerns regarding the overall design.
Module Relevance Check:
Look at each module individually.
Assess its importance and contribution to the project's objectives.
Decide if the module should be kept, modified, or removed based on its relevance.
Module Completeness Check:
Examine the design for any missing functions or components.
Determine what additional modules are needed to fill these gaps.
Consider how these new modules will fit into the existing design.
Compatibility Analysis:
Analyze how well the modules work together.
Focus on matching the inputs and outputs of each module for seamless integration.
Propose changes to enhance compatibility where necessary.
Coherence Evaluation:
Evaluate the design as a whole.
Ensure that the modules collectively form a functional and efficient system.
Assess the overall effectiveness and efficiency of the design in meeting its intended purpose.
Documentation and Rationale:
As you go through each step, explain your reasoning and the basis for your decisions.
Document any proposed changes, including the reasons for additions, removals, or modifications.

Ensure every necessary module for the project is included, not just a subset.
Ensure that the output is in a single JSON.
```json
{{
  "Module_Name": {{
    "ports": ["specific inputs and outputs, including bit width"],
    "description": "detailed description of the module function",
    "connections": ["specific other modules it must connect to"],
  }},
  "Another_Module_Name": {{
    "ports": ["specific inputs and outputs, including bit width"],
    "description": "detailed description of the module function",
    "connections": ["specific other modules it must connect to"],
  }},
  // Include each additional module required for the project
}}
```
"""
        prompt = PromptTemplate(
            template=task_evaluation_template,
            input_variables=["objective", "design"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)

class DesignAndEvaluationChain:
    def __init__(self, llm, verbose=True):
        self.creation_chain = ModuleListCreationChain.from_llm(llm, verbose=verbose)
        self.evaluation_chain = ModuleListEvaluationChain.from_llm(llm, verbose=verbose)
        self.verbose = verbose

    def run(self, objective):
        output_chain_one = self.creation_chain.run(objective)
        if self.verbose:
            print(output_chain_one)
        output_chain_one = strip_json(output_chain_one)
        output_chain_two = self.evaluation_chain.run({'objective':objective, 'design':output_chain_one})
        if self.verbose:
            print(output_chain_two)
        final_output = strip_json(output_chain_two)
        return final_output   

class HDLCreationChain(LLMChain):
    """Chain to generate hdl code."""

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain:
        """Get the response parser."""
        task_creation_template = (
            "You are an expert logic designer. Generate the {module_name} module based on the following description given in between triple backtics. Write the code in {language}."
            " Ensure that your design matches the following descriptions:```\n {description} \n```\n"
            " Ensure the code is synthesizable and the inputs and outputs are consistent with the description."
            " Generate only raw, plain text code - no additional characters, tags, Markdown syntax, backticks, language specification, or explanatory notes should be included."
            " We want just the pure code without any decorations or extras."
        )
        prompt = PromptTemplate(
            template=task_creation_template,
            input_variables=["module_name", "language", "description"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)
    
class HDLEvaluationChain(LLMChain):
    """Chain to evaluate the generated hdl code."""

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain:
        """Get the response parser."""
        task_creation_template = (
            "You are an expert logic designer. Given the module {module_name} code written in {language}:\n" 
            "```\n {module_code} \n```\n"
            " based on the following description given in between triple backtics, decide if the code is aligned with the description."
            "Descriptions:```\n {description} \n```\n"
            "If the code is not aligned with the descrition, explain what problem the code has in markdown format (bullet points). Otherwise respond with: <<<Design OK>>>"
        )
        prompt = PromptTemplate(
            template=task_creation_template,
            input_variables=["module_name", "language", "module_code", "description"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)

class HDLRegenerationChain(LLMChain):
    """Chain to regenerate hdl code based on feedback."""

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain:
        """Get the response parser."""
        task_creation_template = (
            "You are an expert logic designer. Given the module {module_name} code written in {language}.\n" 
            "Code: ```\n {module_code} \n```\n"
            " based on the following description given in between triple backtics after \"description\" and the feedback from another designer given in"
            " between triple backtics after \"feedback\""
            "Descriptions:```\n {description} \n```\n"
            "Feedback:```\n {feedback} \n```\n"
            "regenerate the correct hdl code."
            " Ensure the code is synthesizable and the inputs and outputs are consistent with the description."
            " Generate only raw, plain text code - no additional characters, tags, Markdown syntax, backticks, language specification, or explanatory notes should be included."
        )
        prompt = PromptTemplate(
            template=task_creation_template,
            input_variables=["module_name", "language", "module_code", "description", "feedback"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)

class TestBenchCreationChain(LLMChain):
    """Chain to generate testbench."""

    @classmethod
    def from_llm(cls, llm: BaseLLM, verbose: bool = True) -> LLMChain:
        """Get the response parser."""
        task_creation_template = (
            "Generate a test bench for the {module} give to you after \"module code\"."
            " The top module in your test bench must be called {module}-tb."
            " Make sure that you consider all of the possible corner cases."
            " Generate only raw, plain text code - no additional characters, tags, Markdown syntax, backticks, language specification, or explanatory notes should be included."
            " Only output the code as I will be writing it in a file.\n module code:```\n {module_content} \n```\n"
        )
        prompt = PromptTemplate(
            template=task_creation_template,
            input_variables=["module", "module_content"],
        )
        return cls(prompt=prompt, llm=llm, verbose=verbose)